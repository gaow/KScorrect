pro <- rep(1/G, G)
warning("mixing proportion 'pro' not provided. Assigned equal proportions by default.")
}
if(any(pro < 0L, sd < 0L))
stop("'pro' and 'sd' must not be negative.")
lpro <- length(pro)
if(G < lsd | G < lpro | (lsd > 1 & G != lsd) | (!missing(pro) & G != lpro))
stop("the lengths of supplied parameters do not make sense.")
pro <- as.vector(pro, mode="numeric")
pro <- pro/sum(pro)
pps <- matrix(NA, nreps, npts)
for(n in 1:nreps) { pps[n,] <- sort(rmixnorm(npts, mean=mean, pro=pro, sd=sd)) }
exp <- apply(pps, 2, mean)
lm <- stats::loess(exp ~ ppoints(npts))
pred <- predict(lm, newdata=p)
return(pred)
}
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
pm2
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
round(pm - pn, 3)
round(pm2 - pn, 3)
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm(mean=0, sd=1, pro=1)) # Relatively slow
system.time(qmixnorm(mean=0, sd=1, pro=1)) # Relatively slow
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1)) # Relatively slow
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1)) # loess doesn't add much time
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1)) # loess doesn't add much time
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
pnorm(0)
quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1)
pnorm(quartiles, mean=10, sd=1)
quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1)
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1))
pmixnorm(quartiles, mean=10, sd=1)
(quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1))
pmixnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1))
pmixnorm(quartiles, mean=10, sd=1)
pmixnorm(quartiles, mean=10, sd=1, pro=1)
## Now see if pmixnorm and qmixnorm work together:
# First confirm for normal distributions:
(quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1))
pmixnorm(quartiles, mean=10, sd=1, pro=1)
# First confirm for normal distributions:
(quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, nreps=10000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000)
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000))
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000))
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000))
(quartiles <- qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=10, sd=1, pro=1, npts=1000))
(quartiles <- qnorm(c(.1, .25, .5, .75, .9), mean=10, sd=1))
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
qmixnorm
pmixnorm
?qnorm
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000))
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000, nreps=10000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000, nreps=10000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=10000, nreps=10000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
ps
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=10000, nreps=5000))
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=5000, nreps=10000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
ps
(quartiles <- qnorm(p=ps, mean=10, sd=1)
)
qmixnorm2 <- function (p, npts=100, nreps=5000, mean, sd, pro) {
if(any(missing(p), missing(mean), missing(sd)))
stop("'p', mean' and/or 'sd' not provided, without default.")
if(any(p < 0L) | any(p > 1L))
stop("'p' must be within range 0-1.")
p <- as.vector(p, mode="numeric")
mean <- as.vector(mean, mode="numeric")
G <- length(mean)
sd <- as.vector(sd, mode="numeric")
lsd <- length(sd)
if (missing(pro)) {
pro <- rep(1/G, G)
warning("mixing proportion 'pro' not provided. Assigned equal proportions by default.")
}
if(any(pro < 0L, sd < 0L))
stop("'pro' and 'sd' must not be negative.")
lpro <- length(pro)
if(G < lsd | G < lpro | (lsd > 1 & G != lsd) | (!missing(pro) & G != lpro))
stop("the lengths of supplied parameters do not make sense.")
pro <- as.vector(pro, mode="numeric")
pro <- pro/sum(pro)
pps <- matrix(NA, nreps, npts)
for(n in 1:nreps) { pps[n,] <- sort(rmixnorm(npts, mean=mean, pro=pro, sd=sd)) }
exp <- apply(pps, 2, mean)
lm <- stats::loess(exp ~ ppoints(npts), span=.5)
pred <- predict(lm, newdata=p)
return(pred)
}
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
round(pm2 - pn, 3) # similar results as above
## Timing:
# adding loess & predict.loess doesn't add much time
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
## Now see if pmixnorm and qmixnorm work together:
# First confirm for normal distributions:
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
# The lack of convergence for the extrema concerns me. Could this be an edge effect for loess?
qmixnorm2 <- function (p, npts=100, nreps=5000, mean, sd, pro) {
if(any(missing(p), missing(mean), missing(sd)))
stop("'p', mean' and/or 'sd' not provided, without default.")
if(any(p < 0L) | any(p > 1L))
stop("'p' must be within range 0-1.")
p <- as.vector(p, mode="numeric")
mean <- as.vector(mean, mode="numeric")
G <- length(mean)
sd <- as.vector(sd, mode="numeric")
lsd <- length(sd)
if (missing(pro)) {
pro <- rep(1/G, G)
warning("mixing proportion 'pro' not provided. Assigned equal proportions by default.")
}
if(any(pro < 0L, sd < 0L))
stop("'pro' and 'sd' must not be negative.")
lpro <- length(pro)
if(G < lsd | G < lpro | (lsd > 1 & G != lsd) | (!missing(pro) & G != lpro))
stop("the lengths of supplied parameters do not make sense.")
pro <- as.vector(pro, mode="numeric")
pro <- pro/sum(pro)
pps <- matrix(NA, nreps, npts)
for(n in 1:nreps) { pps[n,] <- sort(rmixnorm(npts, mean=mean, pro=pro, sd=sd)) }
exp <- apply(pps, 2, mean)
lm <- stats::loess(exp ~ ppoints(npts), span=.25)
pred <- predict(lm, newdata=p)
return(pred)
}
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
round(pm2 - pn, 3) # similar results as above
## Timing:
# adding loess & predict.loess doesn't add much time
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
## Now see if pmixnorm and qmixnorm work together:
# First confirm for normal distributions:
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
qmixnorm2 <- function (p, npts=100, nreps=5000, mean, sd, pro) {
if(any(missing(p), missing(mean), missing(sd)))
stop("'p', mean' and/or 'sd' not provided, without default.")
if(any(p < 0L) | any(p > 1L))
stop("'p' must be within range 0-1.")
p <- as.vector(p, mode="numeric")
mean <- as.vector(mean, mode="numeric")
G <- length(mean)
sd <- as.vector(sd, mode="numeric")
lsd <- length(sd)
if (missing(pro)) {
pro <- rep(1/G, G)
warning("mixing proportion 'pro' not provided. Assigned equal proportions by default.")
}
if(any(pro < 0L, sd < 0L))
stop("'pro' and 'sd' must not be negative.")
lpro <- length(pro)
if(G < lsd | G < lpro | (lsd > 1 & G != lsd) | (!missing(pro) & G != lpro))
stop("the lengths of supplied parameters do not make sense.")
pro <- as.vector(pro, mode="numeric")
pro <- pro/sum(pro)
pps <- matrix(NA, nreps, npts)
for(n in 1:nreps) { pps[n,] <- sort(rmixnorm(npts, mean=mean, pro=pro, sd=sd)) }
exp <- apply(pps, 2, mean)
lm <- stats::loess(exp ~ ppoints(npts), span=.1)
pred <- predict(lm, newdata=p)
return(pred)
}
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
round(pm2 - pn, 3) # similar results as above
## Timing:
# adding loess & predict.loess doesn't add much time
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
## Now see if pmixnorm and qmixnorm work together:
# First confirm for normal distributions:
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 2) # Not much difference
# The lack of convergence for the extrema concerns me. Could this be an edge effect for loess?
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3)
# OK approximations. Let's increase the nreps and npts
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=10000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=1000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
qmixnorm
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=200)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3)
# OK approximations. Let's increase the nreps and npts 500%
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=25000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=500)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
## Number of probability points to use when building models
# Larger numbers are more precise.
num <- 100
# Observe normal quantiles as the "known" values
pps <- ppoints(num)
qn <- qnorm(pps)
plot(pps, qn, type="l", lwd=5)
ln <- loess(qn ~ pps) # Fit a loess to the quantile curve
lines(ln, col="red", lty=2, lwd=5)
(pn <- predict(ln, newdata=c(.1, .25, .5, .75, .9))) # Known quantiles for a normal
# Do the same with a one-component 'mixture'
library(KScorrect)
qm <- qmixnorm(npts=num, mean=0, sd=1, pro=1)
lines(pps, qm, type="l", lwd=2, col="darkgray")
lm <- loess(qm ~ pps)
lines(lm, col="white", lty=3, lwd=2)
(pm <- predict(lm, newdata=c(.1, .25, .5, .75, .9)))
# Error:
round(pm - pn, 3) # Extrema have greater errors (as expected), but generally small errors
# Percent error:
round(100 * (pm - pn) / pn, 2) # Large percent error for median reflects small value in denominator. Extrema  maintain relatively larger errors
## Now incorporate the solution into qmixnorm
# p = vector of probabilities
# # Note I've dropped the 'span' value in loess from default=.75 to .10. This controls what proportion of nearby points are used for each loess estimate. Using the default causes edge effects. and given the nicely monotonic relationship involved here, there's no benefit for using distant observations.
qmixnorm2 <- function (p, npts=100, nreps=5000, mean, sd, pro) {
if(any(missing(p), missing(mean), missing(sd)))
stop("'p', mean' and/or 'sd' not provided, without default.")
if(any(p < 0L) | any(p > 1L))
stop("'p' must be within range 0-1.")
p <- as.vector(p, mode="numeric")
mean <- as.vector(mean, mode="numeric")
G <- length(mean)
sd <- as.vector(sd, mode="numeric")
lsd <- length(sd)
if (missing(pro)) {
pro <- rep(1/G, G)
warning("mixing proportion 'pro' not provided. Assigned equal proportions by default.")
}
if(any(pro < 0L, sd < 0L))
stop("'pro' and 'sd' must not be negative.")
lpro <- length(pro)
if(G < lsd | G < lpro | (lsd > 1 & G != lsd) | (!missing(pro) & G != lpro))
stop("the lengths of supplied parameters do not make sense.")
pro <- as.vector(pro, mode="numeric")
pro <- pro/sum(pro)
pps <- matrix(NA, nreps, npts)
for(n in 1:nreps) { pps[n,] <- sort(rmixnorm(npts, mean=mean, pro=pro, sd=sd)) }
exp <- apply(pps, 2, mean)
lm <- stats::loess(exp ~ ppoints(npts), span=.1)
pred <- predict(lm, newdata=p)
return(pred)
}
pm2 <- qmixnorm2(p=c(.1, .25, .5, .75, .9), npts=num, mean=0, sd=1, pro=1)
round(pm2 - pn, 3) # similar results as above
## Timing:
# adding loess & predict.loess doesn't add much time
system.time(qmixnorm(mean=0, sd=1, pro=1))
system.time(qmixnorm2(.5, mean=0, sd=1, pro=1))
system.time(qmixnorm2(p=c(.1, .25, .5, .75, .9), mean=0, sd=1, pro=1))
ps <- c(.1, .25, .5, .75, .9)
(quartiles <- qnorm(ps, mean=10, sd=1))
pnorm(quartiles, mean=10, sd=1)
(quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1))
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3)
# OK approximations. Let's increase the nreps and npts 500%
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, nreps=25000)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # Not much difference
quartiles <- qmixnorm2(p=ps, mean=10, sd=1, pro=1, npts=500)
round(pmixnorm(quartiles, mean=10, sd=1, pro=1), 3) # npts seems more important
q()
devtools::use_build_ignore("qmixnorm_old.R")
library(KScorrect)
rnorm(-1)
rmixnorm(-1)
rmixnorm(-1, mean=10, sd=1)
rnorm(.5)
rnorm(1.5)
rmixnorm(1, mean=10, sd=1)
rmixnorm(1, mean=10, sd=1, pro=1)
rmixnorm(.5, mean=10, sd=1, pro=1)
rmixnorm(1.5, mean=10, sd=1, pro=1)
rmixnorm
?quantile
library(KScorrect)
library(KScorrect)
qmixnorm
library(KScorrect)
library(KScorrect)
r<-rmixnorm(1000, 10, 1, 1)
hist(r)
r<-rmixnorm(1000, c(10, 20), 1, 1)
r<-rmixnorm(1000, c(10, 20), c(1,1))
hist(r)
qmixnorm(.5, 10, 1, 1)
qmixnorm
library(KScorrect)
library(KScorrect)
qmixnorm(.5, 10, 1, 1)
qmixnorm(.5, 10, 1, pro=1)
qmixnorm(.5, mean=10, sd=1, pro=1)
qmixnorm(.5, mean=10, sd=1, pro=1)
qmixnorm(.5, mean=10, sd=1, pro=1)
qmixnorm(.5, mean=10, sd=1, pro=1, ns=500000)
qmixnorm(.5, mean=10, sd=1, pro=1, ns=500000)
qmixnorm(.5, mean=10, sd=1, pro=1, ns=500000)
qmixnorm(.5, mean=10, sd=1, pro=1, ns=5000000)
qmixnorm(ppoints(10), mean=10, sd=1, pro=1, ns=50000)
plot(qmixnorm(ppoints(10), mean=10, sd=1, pro=1, ns=50000))
plot(qmixnorm(ppoints(100), mean=10, sd=1, pro=1, ns=50000))
plot(qmixnorm(ppoints(1000), mean=10, sd=1, pro=1, ns=50000))
plot(qmixnorm(ppoints(1000), mean=c(10,11), sd=c(1,1), pro=1, ns=50000))
plot(qmixnorm(ppoints(1000), mean=c(10,11), sd=c(1,1), pro=c(1,1), ns=50000))
plot(qmixnorm(ppoints(1000), mean=c(10,11), sd=c(1,.1), pro=c(1,1), ns=50000))
hist(rmixnorm(100000, mean=c(10,11), sd=c(1,.1), pro=c(1,1))
)
hist(rmixnorm(100000, mean=c(10,11), sd=c(1,.1), pro=c(1,1)), n=100)
plot(qmixnorm(ppoints(1000), mean=c(10,11), sd=c(1,.1), pro=c(1,1), ns=50000))
plot(qmixnorm(ppoints(1000), mean=c(10,12), sd=c(1,.1), pro=c(1,1), ns=50000))
plot(ppoints(1000), qmixnorm(ppoints(1000), mean=c(10,12), sd=c(1,.1), pro=c(1,1), ns=50000))
plot(ppoints(1000), qmixnorm(ppoints(1000), mean=c(10,12, 15), sd=c(1,.1, 1), pro=c(1, 1,1), ns=50000))
hist(rmixnorm(ppoints(1000), mean=c(10,12, 15), sd=c(1,.1, 1), pro=c(1, 1,1), ns=50000), n=100)
hist(rmixnorm(100000, mean=c(10,12, 15), sd=c(1,.1, 1), pro=c(1, 1,1)), n=100)
hist(rmixnorm(100000, mean=c(10,12, 15), sd=c(1,.1, 1), pro=c(2, 1,2)), n=100)
hist(rmixnorm(100000, mean=c(10,12, 15), sd=c(1,.1, 1), pro=c(5, 1,5)), n=100)
hist(rmixnorm(100000, mean=c(10,12.5, 15), sd=c(1,.1, 1), pro=c(5, 1,5)), n=100)
hist(rmixnorm(100000, mean=c(5, 10,12.5, 15), sd=c(3, 1,.1, 1), pro=c(5, 5, 1,5)), n=100)
library(KScorrect)
?dmixnorm
library(KScorrect)
?dmixnorm
library(KScorrect)
library(KScorrect)
?dmixnorm
?dnorm
?runif
mode(NULL)
mode(NULL)=="numeric"
library(KScorrect)
library(KScorrect)
library(KScorrect)
?rmixnorm
?rmixnorm
library(KScorrect)
rm(list=ls())
library(KScorrect)
?rmixnorm
library(KScorrect)
?dmixnorm
library(KScorrect)
library(KScorrect)
?dmixnorm
pro=NULL
missing(pro)
missing(m)
library(KScorrect)
library(KScorrect)
?dmixnorm
library(KScorrect)
library(KScorrect)
library(KScorrect)
library(KScorrect)
?dmixnorm
?qlunif
qmixnorm(.5, 1, 1)
qmixnorm(.5, 1, 1, nr=1000000)
qmixnorm(.5, c(1,2), 1, nr=1000000)
q()
library(KScorrect)
?dmixnorm
?quantile
mean <- c(3, 6)
pro <- c(.25, .75)
sd <- c(.5, 1)
x <- rmixnorm(n=5000, mean=mean, pro=pro, sd=sd)
hist(x, n=20, main="random bimodal sample")
require(mclust)
# Confirm 'rmixnorm' above produced specified model
mod <- mclust::Mclust(x)
mod             # Best model (correctly) has two-components with unequal variances
mod$parameters	# and approximately same parameters as specified above
sd^2            # Note reports var (sigma-squared) instead of sd used above
}
plot(seq(0, 10, .1), dmixnorm(seq(0, 10, .1), mean=mean, pro=pro, sd=sd),
type="l", main="Normal mixture density")
plot(seq(0, 10, .1), pmixnorm(seq(0, 10, .1), mean=mean, pro=pro, sd=sd),
type="l", main="Normal mixture cumulative")
?qnorm
plot(seq(0, 10, .1), dmixnorm(seq(0, 10, .1), mean=mean, sd=sd, pro=pro),
type="l", main="Normal mixture density")
plot(seq(0, 10, .1), pmixnorm(seq(0, 10, .1), mean=mean, sd=sd, pro=pro),
type="l", main="Normal mixture cumulative")
plot(seq(0, 1, .01), qmixnorm(seq(0, 1, .01), mean=mean, sd=sd, pro=pro),
type="l", main="Normal mixture quantile")
x <- rmixnorm(n=5000, mean=0, pro=1, sd=1)
mpar <- mclust::Mclust(x)$param
approx <- qmixnorm(mean=mpar$mean, pro=mpar$pro,
sd=sqrt(mpar$variance$sigmasq))
approx <- qmixnorm(p=seq(0, 1, .01), mean=mpar$mean, pro=mpar$pro,
sd=sqrt(mpar$variance$sigmasq))
known <- qnorm(seq(0, 1, .01), mean=mpar$mean, sd=sqrt(mpar$variance$sigmasq))
cor(approx, known)  # Approximately the same
approx <- qmixnorm(p=seq(0, 1, .01), mean=mpar$mean, pro=mpar$pro,
sd=sqrt(mpar$variance$sigmasq))
approx
known <- qnorm(seq(0, 1, .01), mean=mpar$mean, sd=sqrt(mpar$variance$sigmasq))
known
ppoints(100)
approx <- qmixnorm(p=ppoints(100), mean=mpar$mean, pro=mpar$pro,
sd=sqrt(mpar$variance$sigmasq))
known <- qnorm(p=ppoints(100), mean=mpar$mean, sd=sqrt(mpar$variance$sigmasq))
approx
known
as.vector(approx)
as.vector(approx[1])
library(KScorrect)
qmixnorm
approx <- qmixnorm(p=ppoints(100), mean=mpar$mean, pro=mpar$pro,
sd=sqrt(mpar$variance$sigmasq))
known <- qnorm(p=ppoints(100), mean=mpar$mean, sd=sqrt(mpar$variance$sigmasq))
cor(approx, known)  # Approximately the same
plot(approx, main="Quantiles for (unimodal) normal")
lines(known)
legend("topleft", legend=c("known", "approximation"), pch=c(NA,1),
lty=c(1, NA), bty="n")
library(KScorrect)
library(KScorrect)
library(KScorrect)
?qmixnorm
